Index: app/src/main/java/com/example/noteexample/viewmodels/EditNoteViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.noteexample.viewmodels\n\nimport androidx.lifecycle.*\nimport com.example.noteexample.database.Header\nimport com.example.noteexample.database.Image\nimport com.example.noteexample.database.NoteWithImages\nimport com.example.noteexample.repository.NoteRepository\nimport com.example.noteexample.adapters.NoteWithImagesRecyclerItems\nimport com.example.noteexample.database.FirstNote\nimport kotlinx.coroutines.launch\nimport java.text.SimpleDateFormat\nimport java.util.*\n\n/**\n * ViewModel for [com.example.noteexample.ui.EditNoteFragment]\n */\nclass EditNoteViewModel(\n    private val noteID: Long = -1,\n    private val repository: NoteRepository\n) : ViewModel() {\n\n    /**\n     * [allHidden] checks if every img is hidden and doesn't have signature\n     * [backPressed] checks if user pressed backButton\n     * [itemListSame] prevents full [noteList] update to prevent submit another list,\n     * which cause unacceptable animation\n     */\n    //Flags\n    var allHidden = true\n    var backPressed = false\n    var itemListSame = false\n\n\n    //Variables\n    var position = 0\n    var startNote: NoteWithImages? = null\n    var currentNote: NoteWithImages? = null\n    var noteList = mutableListOf<NoteWithImagesRecyclerItems>()\n\n    //LiveData\n    val currentNoteLiveData: LiveData<NoteWithImages>\n\n    private val _navigateBack = MutableLiveData<Boolean>()\n    val navigateBack: LiveData<Boolean> = _navigateBack\n\n    init {\n        /**\n         * this LiveData get it's value asynchronously,\n         * for new note it inserts new Header object in DB,\n         * for existing note it gets value from DB\n         */\n        currentNoteLiveData = liveData {\n            emitSource(getNote())\n        }\n    }\n\n    /**\n     * [swapImgs] is attached to [com.example.noteexample.ui.EditNoteFragment.helper]\n     * to sort images manually, this function swaps imgIDs\n     */\n    fun swapImgs(from: Int, to: Int) {\n        itemListSame = true\n        currentNote?.let {\n            val tmpID = it.images[from].imgID\n            it.images[from].imgID = it.images[to].imgID\n            it.images[to].imgID = tmpID\n        }\n    }\n\n    fun swapNotes(list: List<FirstNote>, from: Int, to: Int) {\n        itemListSame = true\n        val tmpID = list[from].noteID\n        list[from].noteID = list[to].noteID\n        list[to].noteID = tmpID\n    }\n\n    /**\n     * Insert note in [com.example.noteexample.ui.EditNoteFragment.startCamera]\n     */\n    fun insertCameraPhoto(path: String) {\n        viewModelScope.launch {\n            currentNote?.let {\n                val localList = it.images.filter { list -> list.hidden }\n                if (localList.isEmpty()) {\n                    val image = Image(\n                        parentImgNoteID = it.header.headerID,\n                        photoPath = path\n                    )\n                    repository.insertImage(image)\n                } else {\n                    localList[0].apply {\n                        photoPath = path\n                        hidden = false\n                        repository.updateImage(this)\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Emit source for [currentNoteLiveData]\n     */\n    private suspend fun getNote(): LiveData<NoteWithImages> {\n        return if (noteID > -1) {\n            startNote = repository.getNote(noteID)\n            repository.getNoteLiveData(noteID)\n        } else {\n            position = repository.allASCSortedNotes().size\n            val header = Header(pos = position)\n            repository.insertHeader(header)\n            val firstNote = FirstNote(parentNoteID = repository.getLastNote().header.headerID)\n            repository.insertFirstNote(firstNote)\n            startNote = repository.getLastNote()\n            repository.getLastLiveData()\n        }\n    }\n\n    /**\n     * Database methods\n     */\n\n    fun updateCurrentNote(list: List<FirstNote>? = null) {\n        viewModelScope.launch {\n            if (noteID > -1) {\n                currentNote?.let {\n                    repository.updateNoteWithImages(it)\n                }\n            } else {\n                /**\n                 * Each note has it's date\n                 * @see com.example.noteexample.database.Header.date\n                 */\n                val cal = Calendar.getInstance().time\n                val time =\n                    SimpleDateFormat(\"HH:mm EE dd MMM\", Locale.getDefault()).format(cal)\n                currentNote?.let {\n                    it.header.date = time\n                    repository.updateNoteWithImages(it)\n                }\n            }\n            list?.let {\n                repository.updateFirstNotes(it)\n            }\n        }\n    }\n\n    suspend fun insertNoteWithImages(noteWithImages: NoteWithImages?) {\n        noteWithImages?.let {\n            repository.insertNoteWithImages(noteWithImages)\n        }\n    }\n\n    suspend fun deleteNoteWithImages(noteWithImages: NoteWithImages?) {\n        noteWithImages?.let {\n            repository.deleteNoteWithImages(it)\n        }\n    }\n\n    fun deleteFirstNote(firstNote: FirstNote) {\n        viewModelScope.launch {\n            repository.deleteFirstNote(firstNote)\n        }\n    }\n\n    fun updateFirstNote(list: List<FirstNote>) {\n        viewModelScope.launch {\n            repository.updateFirstNotes(list)\n        }\n    }\n\n    fun insertNewFirstNote() {\n        viewModelScope.launch {\n            currentNote?.let {\n                val firstNote = FirstNote(parentNoteID = it.header.headerID)\n                repository.insertFirstNote(firstNote)\n            }\n        }\n    }\n\n    fun deleteImage(image: Image) {\n        viewModelScope.launch {\n            repository.deleteImage(image)\n        }\n    }\n\n    suspend fun deleteUnused() {\n        currentNote?.let { repository.deleteNoteWithImages(it) }\n    }\n\n    /**\n     * Methods for [navigateBack] LiveData\n     * it triggers closure of [com.example.noteexample.ui.EditNoteFragment]\n     */\n\n    fun onStartNavigating() {\n        _navigateBack.value = true\n    }\n\n    fun onDoneNavigating() {\n        _navigateBack.value = false\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/noteexample/viewmodels/EditNoteViewModel.kt	(revision db9dbe98862f37dbc171cc31551b7772e2c8259b)
+++ app/src/main/java/com/example/noteexample/viewmodels/EditNoteViewModel.kt	(date 1610207723000)
@@ -67,11 +67,13 @@
         }
     }
 
-    fun swapNotes(list: List<FirstNote>, from: Int, to: Int) {
+    fun swapNotes(from: Int, to: Int) {
         itemListSame = true
-        val tmpID = list[from].noteID
-        list[from].noteID = list[to].noteID
-        list[to].noteID = tmpID
+        currentNote?.let {
+            val tmpID = it.notes[from].noteID
+            it.notes[from].noteID = it.notes[to].noteID
+            it.notes[to].noteID = tmpID
+        }
     }
 
     /**
Index: app/src/main/java/com/example/noteexample/ui/EditNoteFragment.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.noteexample.ui\n\nimport android.Manifest\nimport android.annotation.SuppressLint\nimport android.app.Activity\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.os.Bundle\nimport android.view.LayoutInflater\nimport android.view.View\nimport android.view.ViewGroup\nimport android.view.inputmethod.EditorInfo\nimport androidx.activity.addCallback\nimport androidx.activity.result.ActivityResultLauncher\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.core.content.ContextCompat\nimport androidx.core.widget.addTextChangedListener\nimport androidx.databinding.DataBindingUtil\nimport androidx.fragment.app.Fragment\nimport androidx.fragment.app.viewModels\nimport androidx.lifecycle.lifecycleScope\nimport androidx.navigation.fragment.findNavController\nimport androidx.navigation.fragment.navArgs\nimport com.example.noteexample.R\nimport com.example.noteexample.adapters.EditNoteAdapter\nimport com.example.noteexample.adapters.NoteWithImagesRecyclerItems\nimport com.example.noteexample.databinding.FragmentEditNoteBinding\nimport com.example.noteexample.repository.NoteRepository\nimport com.example.noteexample.utils.Camera\nimport com.example.noteexample.utils.ItemHelperCallback\nimport com.example.noteexample.viewmodels.EditNoteViewModel\nimport com.example.noteexample.viewmodels.NoteViewModelFactory\nimport com.google.android.material.dialog.MaterialAlertDialogBuilder\nimport com.google.android.material.snackbar.Snackbar\nimport dagger.hilt.android.AndroidEntryPoint\nimport kotlinx.coroutines.*\nimport javax.inject.Inject\n\n@AndroidEntryPoint\nclass EditNoteFragment : Fragment() {\n\n    /**\n     * [requestPermissionLauncher] request permission for storage\n     * [startCamera] opens camera to make and save photo in photoPath\n     *\n     * @see Camera\n     */\n\n    @Inject\n    lateinit var camera: Camera\n\n    @Inject\n    lateinit var repository: NoteRepository\n\n    private val noteAdapter = EditNoteAdapter()\n    private val itemHelperCallback = ItemHelperCallback()\n    private val checkboxEditAdapter = noteAdapter.checkBoxEditAdapter\n    private val simpleEditAdapter = noteAdapter.simpleEditAdapter\n\n    private lateinit var requestPermissionLauncher: ActivityResultLauncher<String>\n    private lateinit var startCamera: ActivityResultLauncher<Intent>\n    private val args by navArgs<EditNoteFragmentArgs>()\n\n    private val viewModel by viewModels<EditNoteViewModel> {\n        NoteViewModelFactory(args.noteID, repository)\n    }\n\n    private val imgHelper = itemHelperCallback.getHelper(\n        range = 2,\n        swapAction = { from: Int, to: Int ->\n            viewModel.swapImgs(from, to)\n        },\n        clearViewAction = {\n            viewModel.updateCurrentNote()\n        }\n    )\n\n    private val firstNoteHelper = itemHelperCallback.getHelper(\n        range = 0,\n        swapAction = { from: Int, to: Int ->\n            viewModel.swapNotes(checkboxEditAdapter.currentList, from, to)\n        },\n        clearViewAction = {\n            viewModel.updateCurrentNote(checkboxEditAdapter.currentList)\n        }\n    )\n\n\n    @SuppressLint(\"SetTextI18n\")\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n\n        /**\n         * binding for EditNoteFragment\n         * @see R.layout.fragment_edit_note\n         */\n\n        val binding: FragmentEditNoteBinding =\n            DataBindingUtil.inflate(inflater, R.layout.fragment_edit_note, container, false)\n        binding.lifecycleOwner = this\n\n        requestPermissionLauncher =\n            registerForActivityResult(\n                ActivityResultContracts.RequestPermission()\n            ) { isGranted: Boolean ->\n                if (isGranted) {\n                    viewModel.startNote?.header?.let { item ->\n                        this@EditNoteFragment.findNavController()\n                            .navigate(\n                                EditNoteFragmentDirections\n                                    .actionEditNoteFragmentToGalleryFragment(item.headerID)\n                            )\n                    }\n                } else {\n                    Snackbar.make(\n                        binding.editRecycler,\n                        R.string.camera_request_failed,\n                        Snackbar.LENGTH_SHORT\n                    ).show()\n                }\n            }\n\n        //Launcher for camera itself\n        startCamera =\n            registerForActivityResult(\n                ActivityResultContracts.StartActivityForResult()\n            ) {\n                if (it.resultCode == Activity.RESULT_OK) {\n                    viewModel.insertCameraPhoto(camera.currentPhotoPath)\n                    noteAdapter.notifyDataSetChanged()\n                }\n            }\n\n\n        binding.editRecycler.apply {\n            adapter = noteAdapter\n        }\n        imgHelper.attachToRecyclerView(binding.editRecycler)\n\n        //navIcon clickListener\n        binding.toolbarNoteEdit.setNavigationOnClickListener {\n            viewModel.backPressed = true\n            viewModel.onStartNavigating()\n        }\n\n\n        //menuClickListener\n        binding.toolbarNoteEdit.setOnMenuItemClickListener {\n\n//            val newIcon = ContextCompat.getDrawable(requireContext(), R.drawable.ic_back_arrow)\n            when (it.itemId) {\n                R.id.insert_photo -> {\n                    viewModel.updateCurrentNote()\n                    val items =\n                        requireNotNull(this.activity).application\n                            .resources.getStringArray(R.array.dialog_array)\n                    MaterialAlertDialogBuilder(requireContext())\n                        .setItems(items) { _, index ->\n                            when (index) {\n                                0 -> {\n                                    startCamera.launch(\n                                        camera.dispatchTakePictureIntent()\n                                    )\n                                }\n                                1 -> {\n                                    if (ContextCompat.checkSelfPermission(\n                                            requireContext(),\n                                            Manifest.permission.READ_EXTERNAL_STORAGE\n                                        ) == PackageManager.PERMISSION_GRANTED\n                                    ) {\n                                        viewModel.startNote?.header?.let { item ->\n                                            this@EditNoteFragment.findNavController()\n                                                .navigate(\n                                                    EditNoteFragmentDirections\n                                                        .actionEditNoteFragmentToGalleryFragment(\n                                                            item.headerID\n                                                        )\n                                                )\n                                        }\n\n                                    } else {\n                                        requestPermissionLauncher.launch(\n                                            Manifest.permission.READ_EXTERNAL_STORAGE\n                                        )\n                                    }\n                                }\n                            }\n                        }.show()\n                    true\n                }\n                R.id.todo -> {\n                    viewModel.currentNote?.header?.let { header ->\n                        if (header.todoList) {\n                            it.icon = ContextCompat.getDrawable(\n                                requireContext(),\n                                R.drawable.ic_todo_list\n                            )\n                            header.todoList = false\n                            viewModel.updateCurrentNote(checkboxEditAdapter.currentList)\n                            noteAdapter.notifyDataSetChanged()\n                        } else {\n                            it.icon = ContextCompat.getDrawable(\n                                requireContext(),\n                                R.drawable.ic_simple_list\n                            )\n                            header.todoList = true\n                            viewModel.updateCurrentNote(simpleEditAdapter.currentList)\n                            noteAdapter.notifyDataSetChanged()\n                        }\n                    }\n                    true\n                }\n                R.id.save_note -> {\n                    viewModel.onStartNavigating()\n                    true\n                }\n                else -> false\n            }\n        }\n\n        /**\n         * LiveData for header\n         * @see EditNoteAdapter.headerHolder\n         *\n         * TextChangeListener write title and text values and updates them when exit\n         * or accidentally close app if this is note is new\n         * @see onPause\n         */\n\n        noteAdapter.headerHolder.observe(viewLifecycleOwner) { holder ->\n            holder.binding.titleEdit.addTextChangedListener {\n                viewModel.currentNote?.header?.title = it.toString()\n            }\n        }\n\n        noteAdapter.firstNoteHolder.observe(viewLifecycleOwner, {\n            firstNoteHelper.attachToRecyclerView(it.binding.recyclerFirstNote)\n        })\n\n//            holder.binding.firstNoteEdit.imeOptions = EditorInfo.IME_MASK_ACTION\n//            holder.binding.firstNoteEdit.setRawInputType(InputType.TYPE_CLASS_TEXT)\n\n        simpleEditAdapter.simpleHolder.observe(viewLifecycleOwner, { holder ->\n            holder.binding.firstNoteEdit.setOnEditorActionListener { _, actionId, _ ->\n                return@setOnEditorActionListener when (actionId) {\n                    EditorInfo.IME_ACTION_NEXT -> {\n                        noteAdapter.currentList[1]\n                            .firstNote?.get(holder.absoluteAdapterPosition)?.let {\n                                it.text = \"${it.text}\\n\"\n                            }\n                        viewModel.updateFirstNote(checkboxEditAdapter.currentList)\n                        viewModel.insertNewFirstNote()\n                        true\n                    }\n                    else -> false\n                }\n            }\n\n            holder.binding.firstNoteEdit.addTextChangedListener {\n                simpleEditAdapter.currentList[holder.absoluteAdapterPosition].text =\n                    it.toString()\n            }\n        })\n\n        checkboxEditAdapter.checkBoxHolder.observe(viewLifecycleOwner, { holder ->\n\n            holder.binding.editTextCheckbox.addTextChangedListener {\n                checkboxEditAdapter.currentList[holder.absoluteAdapterPosition].text =\n                    it.toString()\n            }\n\n            holder.binding.editTextCheckbox.setOnEditorActionListener { _, actionId, _ ->\n                return@setOnEditorActionListener when (actionId) {\n                    EditorInfo.IME_ACTION_DONE -> {\n                        viewModel.updateFirstNote(checkboxEditAdapter.currentList)\n                        viewModel.insertNewFirstNote()\n                        true\n                    }\n                    else -> false\n                }\n            }\n\n            holder.binding.deleteFirstNoteItemButton.setOnClickListener {\n                viewModel.deleteFirstNote(\n                    checkboxEditAdapter.currentList[holder.absoluteAdapterPosition]\n                )\n            }\n        })\n\n\n        /**\n         * LiveData for images\n         * @see EditNoteAdapter.imgHolder\n         *\n         * set visibility and clickListeners when the\n         * image is in normal state or in hidden state\n         * @see com.example.noteexample.database.Image.hidden\n         */\n\n        noteAdapter.imgHolder.observe(viewLifecycleOwner, { holder ->\n\n            //set state between normal and hidden state\n            if (noteAdapter.currentList[holder.absoluteAdapterPosition].image?.hidden == true) {\n                holder.binding.photo.visibility = View.GONE\n                holder.binding.restoreButton.visibility = View.VISIBLE\n                holder.binding.deleteCircleIcon.visibility = View.GONE\n                holder.binding.deleteCircle.visibility = View.GONE\n            } else {\n                holder.binding.photo.visibility = View.VISIBLE\n                holder.binding.restoreButton.visibility = View.GONE\n                holder.binding.deleteCircleIcon.visibility = View.VISIBLE\n                holder.binding.deleteCircle.visibility = View.VISIBLE\n            }\n\n            //save current signature\n            holder.binding.noteEditTextFirst.addTextChangedListener { editable ->\n                noteAdapter.currentList[holder.absoluteAdapterPosition].image?.let {\n                    it.signature = editable.toString()\n                    if (it.photoPath.isEmpty() && it.signature.isEmpty()) {\n                        viewModel.deleteImage(it)\n                    }\n                }\n            }\n\n            /**\n             * When delete circle is pressed, image disappears\n             * and restore button becomes [View.VISIBLE]\n             */\n            holder.binding.deleteCircle.setOnClickListener {\n                noteAdapter.currentList[holder.absoluteAdapterPosition].image?.hidden = true\n                viewModel.updateCurrentNote()\n                noteAdapter.notifyItemChanged(holder.absoluteAdapterPosition)\n            }\n\n            /**\n             * Restore button retuns image in normal state\n             */\n            holder.binding.restoreButton.setOnClickListener {\n                noteAdapter.currentList[holder.absoluteAdapterPosition].image?.hidden = false\n                viewModel.updateCurrentNote()\n                noteAdapter.notifyItemChanged(holder.absoluteAdapterPosition)\n            }\n        })\n\n\n        /**\n         * Back button triggers [EditNoteViewModel.navigateBack] LiveData\n         */\n        requireActivity().onBackPressedDispatcher.addCallback(viewLifecycleOwner) {\n            viewModel.backPressed = true\n            viewModel.onStartNavigating()\n        }\n        /**\n         * [EditNoteViewModel.currentNoteLiveData] submits list for [EditNoteAdapter]\n         *\n         * It doesn't define new list each time to prevent blinks each time\n         * [EditNoteViewModel.currentNoteLiveData] is observed\n         */\n        //TODO Fix item touch helpers\n        viewModel.currentNoteLiveData.observe(viewLifecycleOwner, {\n            viewModel.currentNote = it\n            lifecycleScope.launch(Dispatchers.Default) {\n                it?.let { note ->\n                    if (!viewModel.itemListSame) {\n                        viewModel.noteList = mutableListOf()\n                        viewModel.noteList.add(0, NoteWithImagesRecyclerItems(note.header))\n                        viewModel.noteList.add(\n                            1,\n                            NoteWithImagesRecyclerItems(firstNote = note.notes)\n                        )\n                        note.images.forEach { image ->\n                            viewModel.noteList.add(NoteWithImagesRecyclerItems(image = image))\n                        }\n                    } else {\n                        viewModel.noteList.forEachIndexed { index, item ->\n                            if (index == 1) {\n                                item.firstNote = note.notes\n                            }\n                            if (index > 1) {\n                                item.image = note.images[index - 2]\n                            }\n                        }\n                        viewModel.itemListSame = false\n                    }\n                    withContext(Dispatchers.Main) {\n                        noteAdapter.submitList(viewModel.noteList)\n                    }\n                }\n            }\n        })\n\n\n\n        //Inner function to reduce repetitive code\n        fun checkAndNavigate() {\n            lifecycleScope.launch {\n                viewModel.currentNote?.let {\n                    if (it.images.isEmpty() &&\n                        it.header.title.isEmpty() &&\n                        it.notes.isEmpty() &&\n                        viewModel.allHidden\n                    ) {\n                        viewModel.deleteUnused()\n                    }\n                }\n                this@EditNoteFragment.findNavController()\n                    .navigate(\n                        EditNoteFragmentDirections.actionEditNoteFragmentToAllNotesFragment()\n                    )\n                viewModel.onDoneNavigating()\n            }\n        }\n\n\n        /**\n         * [EditNoteViewModel.startNote] and [EditNoteViewModel.currentNote]\n         * checks if note is changed comparable to start state\n         */\n        viewModel.navigateBack.observe(viewLifecycleOwner, {\n            if (it == true) {\n                viewModel.updateCurrentNote()\n                viewModel.currentNote?.let { noteWithImages ->\n                    if (noteWithImages.images.any { item -> !item.hidden } ||\n                        noteWithImages.images.any { item -> item.signature.isNotEmpty() }) {\n                        viewModel.allHidden = false\n                    }\n                    when {\n                        viewModel.backPressed -> {\n                            if (viewModel.startNote?.header?.title != noteWithImages.header.title ||\n                                viewModel.startNote?.notes != noteWithImages.notes ||\n                                viewModel.startNote?.images != noteWithImages.images\n                            ) {\n                                MaterialAlertDialogBuilder(requireContext())\n                                    .setMessage(\"Сохранить изменения?\")\n                                    .setNegativeButton(\"Нет\") { _, _ ->\n                                        lifecycleScope.launch {\n                                            if (args.noteID > -1) {\n                                                viewModel.deleteNoteWithImages(noteWithImages)\n                                                viewModel.insertNoteWithImages(viewModel.startNote)\n                                            } else {\n                                                viewModel.deleteUnused()\n                                            }\n                                            this@EditNoteFragment.findNavController().popBackStack()\n                                        }\n                                    }\n                                    .setPositiveButton(\"Да\") { _, _ ->\n                                        checkAndNavigate()\n                                    }.show()\n                                viewModel.onDoneNavigating()\n                            } else {\n                                this.findNavController().popBackStack()\n                                viewModel.onDoneNavigating()\n                            }\n                        }\n                        !viewModel.backPressed -> {\n                            checkAndNavigate()\n                        }\n                    }\n                }\n            }\n        })\n        return binding.root\n    }\n\n    /**\n     * [EditNoteViewModel.updateCurrentNote] updates new note in case app is closed accidentally\n     */\n    override fun onPause() {\n        super.onPause()\n        if (args.noteID == -1L) {\n            viewModel.updateCurrentNote()\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/noteexample/ui/EditNoteFragment.kt	(revision db9dbe98862f37dbc171cc31551b7772e2c8259b)
+++ app/src/main/java/com/example/noteexample/ui/EditNoteFragment.kt	(date 1610209492000)
@@ -78,10 +78,10 @@
     private val firstNoteHelper = itemHelperCallback.getHelper(
         range = 0,
         swapAction = { from: Int, to: Int ->
-            viewModel.swapNotes(checkboxEditAdapter.currentList, from, to)
+            viewModel.swapNotes(from, to)
         },
         clearViewAction = {
-            viewModel.updateCurrentNote(checkboxEditAdapter.currentList)
+            viewModel.updateCurrentNote()
         }
     )
 
